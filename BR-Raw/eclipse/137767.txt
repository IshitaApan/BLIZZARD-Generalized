[Progress] UISynchronizer must clear Interrupt Status of the UI thread

I see in bug 123800 that the reason for the lockListener.interruptUI() call in the UISynchronizer.syncExec() method is to interrupt the UI thread in case it is waiting for a monitor in a deadlock. This seems to be to be a bad idea, because the UISynchronizer has no way of knowing that the UI thread is not actually deadlocked but may be in a wait() that will wake up (possibly even on a timeout). However, if it is not feasible for the UISynchronizer to desist in interrupting the UI thread, it must at least ensure that the UI thread's interrupt status is cleared before it processes the next Runnable or event call-back. If it fails to do so, then a Runnable that invokes a potentially blocking API call will immediately throw an InterruptedException if the API it is calling is well-behaved. It is common (and good) practice in concurrent programming that any potentially blocking method declare that it throws InterruptedException *and* check whether the calling thread is already interrupted upon entering the method (by Thread.interrupted()), and throw if it is. See Doug Lea's "Concurrent Programming in Java" for a discussion. I would like to suggest that the UILockListener.doPendingWork() method call Thread.interrupted() before invoking a Runnable to ensure that the interrupt status is cleared. This would prevent my API's clients from needlessly throwing InterruptedExceptions whenever a client invokes my API's blocking calls within a Display.syncExec().
[Contexts] ContextAction's leak when hiding actions sets

+++ This bug was initially created as a clone of Bug #249995 +++ Looking at a heapdump of a long running RCP based application I see org.eclipse.ui.internal.contexts.SlaveContextService retaining 4MB or 8.7% of the Java heap. Digging deeper I see there are 62,389 instances of org.eclipse.ui.internal.contexts.ContextActivation. I think I understand why there are so many instances, I was able to "recreate" with the "RCP Mail template" example. I changed the OpenViewAction.run method to do the following: for (int i = 0; i < 100; i++) 	window.getActivePage().hideActionSet(getActionDefinitionId()); before running the for loop I took a look at SlaveContextService.fLocalActivations, it was size 3, which is expected. After running this for loop twice I see 400 new instances of ContextActivation in the map. service	org.eclipse.ui.internal.contexts.SlaveContextService (id=58)	 	'service' referenced from:	 	fContextManagerListeners	java.util.ArrayList<E> (id=80)	 	fDefaultExpression	org.eclipse.ui.internal.expressions.WorkbenchWindowExpression (id=82)	 	fLocalActivations	java.util.HashMap<K,V> (id=84)	 		[0...99]	 		[100...199]	 		[200...299]	 		[300...399]	 		[400...403] As I understand the hideActionSet code this is expected since hideActionSet calls Perspective.removeActionSet which contains: IContextService service = (IContextService)page.getWorkbenchWindow().getService(IContextService.class); .... service.activateContext(ContextAuthority.DEFER_EVENTS); service.activateContext(ContextAuthority.SEND_EVENTS); Since the workbench window is global, and deactivateContext isn't called, these will continue to accumulate until the workbench is exited. In the removeActionSet case it would be straightforward to deactivate in the finally block but wondered if I was misunderstanding the code.
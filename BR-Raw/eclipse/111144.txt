WorkingCopyPreferences tries to flush removed pref nodes

This bug is related to a cluster of bugs already reported, all to do with IllegalStateException thrown by EclipsePreferences.checkRemoved(); easiest way to see some of the cluster is to search on "checkRemoved" in comments. The canonical one is perhaps Bug 68993. This could be fixed (and in many places has been) in client code, but I am reporting this against Platform because I think there is an underlying Platform problem that is tripping up a number of downstream consumers. I suggest solutions at the end of this bug report. *** REPRO *** One repro scenario follows: 1. Start with a workspace that contains a Java project, and with JDT core settings all set to defaults (workspace and project). 2. View workspace settings, go to the Java / Compiler pane, and change compiler compliance at the workspace level to 5.0 (so that there's a workspace node). 3. Select "configure project specific settings" and select the project. In project settings, uncheck "preserve unused local variables" (so there's a project node). 4. Ok the project-specific dialog; ok the workspace dialog. 5. Now, again view workspace settings. Select "configure project specific settings" and select the project. 6. In project settings, click "Restore Defaults". 7. Ok the project-specific dialog; ok the workspace dialog. Note that the error log now contains two errors, an "unhandled loop exception" and "preference node org.eclipse.jdt.core has been removed". *** EXPLANATION *** Here's why I think it's happening in this particular case. For readability I've abbreviated some type names: EP = org.eclipse.core.internal.preferences.EclipsePreferences PP = org.eclipse.core.internal.resources.ProjectPreferences WCM = org.eclipse.ui.internal.preferences.WorkingCopyManager OCB = org.eclipse.jdt.internal.ui.preferences.OptionsConfigurationBlock OCB is used to create preferences panes for certain JDT settings. (We also use it as a base class for the jdt.apt settings, which is how I found this; see Bug 106111.) An OCB owns a WCM. WCM owns a map of WCP. Nothing is ever removed from this map. OCB is used to create both the workspace and project-specific panes. Because those dialogs are cross-linked, it is possible to nest a project-specific instance of OCB within a workspace-prefs instance of OCB, by first viewing a workspace pref pane and then linking to a project-specific pref pane. When the "Configure project specific settings" link on the workspace-prefs instance is clicked, OCB.hasProjectSpecificOptions() is called. In figuring out which projects have options, it inadvertently brings project-specific nodes into the WCM's map - that is, the WCM belonging to the parent (workspace) OCB. Later, when the nested (project-specific) OCB is ok'ed, if the changes cause there to be no non-default settings under the project-specific node, then PP.save() deletes the whole project-specific preference file. This results in the file's resource listener being called. Ultimately, that results in a call to PP.deleted(IFile), which calls PP.removeNode() to remove the corresponding project-specific prefs node. Even later, when the parent (workspace) OCB is ok'ed, it calls WCM.applyChanges (). This flushes every WCP in its map, which includes the project-specific WCP. When a WCP is flushed, it calls PP.flush() on the "original" node that backs it. This results in a call to checkRemove(), which throws an exception if the node has been removed. But in this case, the node that backs the project-specific WCP has already been removed. So, the exception is thrown. *** SOLUTIONS *** In a nutshell, the problem is that WCM is inadvertently caching project pref nodes, but those project nodes can get deleted by underlying code. One workaround would be that in OCB, we could implement hasProjectSpecificSettings() differently, without using a WorkingCopyManager (since we're never interested in actually changing the settings discovered there, there's no point in wrapping them in WCM). But that would only fix the problem in one place; Bugzilla contains many instances of people tripping over the same core problem, which is that it's bad to cache pref nodes. I would suggest instead one of two fixes. Minimally, WCM and WCP could be changed to install listeners on the nodes they cache, to remove the WCP from WCM's map if the underlying node is changed. This would solve the WCM problem, but it would still not solve other caching problems. More deeply, I wonder whether it is right for EclipsePreferences to be throwing exceptions when removed nodes are flushed. Perhaps it would be better to just silently ignore attempts to flush removed nodes? If even the developers of WCM/WCP (in the platform code) make the mistake of caching preference nodes, it may be unreasonable to expect better of downstream consumers.
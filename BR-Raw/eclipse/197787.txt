[Viewers] wrong cell editor activated after table refresh

Build ID: I20070625-1500 Steps To Reproduce: to demonstrate the problem I have modified Snippet040TableViewerSorting. for example click on "Tod" and enter the editor. change the name to "zebra" and press enter. the items are rearranged due to a table.refresh() (not really necessary at this point but makes it easier to demonstrate the problem). now press enter again and see the strange behavior (the wrong editor (at the previous item position) is activated with the "correct" content). The modified Snippet: package org.eclipse.swt.snippets; import org.eclipse.core.runtime.Assert; import org.eclipse.jface.viewers.CellEditor; import org.eclipse.jface.viewers.ColumnLabelProvider; import org.eclipse.jface.viewers.ColumnViewer; import org.eclipse.jface.viewers.ColumnViewerEditor; import org.eclipse.jface.viewers.ColumnViewerEditorActivationEvent; import org.eclipse.jface.viewers.ColumnViewerEditorActivationStrategy; import org.eclipse.jface.viewers.EditingSupport; import org.eclipse.jface.viewers.FocusCellHighlighter; import org.eclipse.jface.viewers.IStructuredContentProvider; import org.eclipse.jface.viewers.TableViewer; import org.eclipse.jface.viewers.TableViewerColumn; import org.eclipse.jface.viewers.TableViewerEditor; import org.eclipse.jface.viewers.TableViewerFocusCellManager; import org.eclipse.jface.viewers.TextCellEditor; import org.eclipse.jface.viewers.Viewer; import org.eclipse.jface.viewers.ViewerCell; import org.eclipse.jface.viewers.ViewerComparator; import org.eclipse.jface.viewers.ViewerRow; import org.eclipse.swt.SWT; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.TableItem; import com.swtdesigner.SWTResourceManager; /** * Example usage of ViewerComparator in tables to allow sorting * * @author Tom Schindl <tom.schindl@bestsolution.at> * */ public class Snippet040TableViewerSorting { 	private class MyContentProvider implements IStructuredContentProvider { 		public Object[] getElements(Object inputElement) { 			return (Person[]) inputElement; 		} 		public void dispose() { 		} 		public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { 		} 	} 	public class Person { 		public String givenname; 		public String surname; 		public String email; 		public Person(String givenname, String surname, String email) { 			this.givenname = givenname; 			this.surname = surname; 			this.email = email; 		} 	} 	protected abstract class AbstractEditingSupport extends EditingSupport { 		private TextCellEditor editor; 		public AbstractEditingSupport(TableViewer viewer) { 			super(viewer); 			this.editor = new TextCellEditor(viewer.getTable()); 		} 		protected boolean canEdit(Object element) { 			return true; 		} 		protected CellEditor getCellEditor(Object element) { 			return editor; 		} 		protected void setValue(Object element, Object value) { 			doSetValue(element, value); 			getViewer().update(element, null); 			 			TableViewer tableViewer = (TableViewer) getViewer(); 			 			TableItem item = tableViewer.getTable().getItem(tableViewer.getTable().getSelectionIndex()); 			Object obj = item.getData(); 			 			// refresh table 			tableViewer.refresh();			 			 			// search for the item that has the object from the 			// previously selected item 			TableItem itemtoselect = null; 			TableItem[] items = tableViewer.getTable().getItems(); 			for (TableItem it : items) { 				if (it.getData().equals(obj)) { 					itemtoselect = it; 				} 			} 			// select this item 			tableViewer.getTable().setSelection(itemtoselect); 		} 		protected abstract void doSetValue(Object element, Object value); 	} 	public Snippet040TableViewerSorting(Shell shell) { 		TableViewer v = new TableViewer(shell, SWT.BORDER | SWT.FULL_SELECTION); 		v.setContentProvider(new MyContentProvider()); 		 		final TableViewerFocusCellManager focusCellManager = new TableViewerFocusCellManager(v, new EditableFocusCellHighlighter(v)); 		ColumnViewerEditorActivationStrategy actSupport = new ColumnViewerEditorActivationStrategy(v) { 			protected boolean isEditorActivationEvent( 					ColumnViewerEditorActivationEvent event) { 				if ( event.sourceEvent instanceof KeyEvent && event.keyCode > 31 && event.keyCode < 127) { 					((KeyEvent)event.sourceEvent).doit=false; 				} 				 				return event.eventType == ColumnViewerEditorActivationEvent.TRAVERSAL 						|| event.eventType == ColumnViewerEditorActivationEvent.MOUSE_DOUBLE_CLICK_SELECTION 						|| (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode > 31 && event.keyCode < 127) 						|| (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode == SWT.CR) 						|| (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode == 16777296) 						|| (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED && event.keyCode == SWT.F2) 						|| event.eventType == ColumnViewerEditorActivationEvent.PROGRAMMATIC; 			} 		}; 		TableViewerEditor.create(v, focusCellManager, actSupport, ColumnViewerEditor.TABBING_HORIZONTAL 				| ColumnViewerEditor.TABBING_MOVE_TO_ROW_NEIGHBOR 				| ColumnViewerEditor.TABBING_VERTICAL | ColumnViewerEditor.KEYBOARD_ACTIVATION); 		 		TableViewerColumn column = new TableViewerColumn(v, SWT.NONE); 		column.getColumn().setWidth(200); 		column.getColumn().setText("Givenname"); 		column.getColumn().setMoveable(true); 		column.setLabelProvider(new ColumnLabelProvider() { 			public String getText(Object element) { 				return ((Person) element).givenname; 			} 		}); 		column.setEditingSupport(new AbstractEditingSupport(v) { 			protected Object getValue(Object element) { 				return ((Person) element).givenname; 			} 			protected void doSetValue(Object element, Object value) { 				((Person) element).givenname = value.toString(); 			} 		}); 		 		ColumnViewerSorter cSorter = new ColumnViewerSorter(v,column) { 			protected int doCompare(Viewer viewer, Object e1, Object e2) { 				Person p1 = (Person) e1; 				Person p2 = (Person) e2; 				return p1.givenname.compareToIgnoreCase(p2.givenname); 			} 			 		}; 		column = new TableViewerColumn(v, SWT.NONE); 		column.getColumn().setWidth(200); 		column.getColumn().setText("Surname"); 		column.getColumn().setMoveable(true); 		column.setLabelProvider(new ColumnLabelProvider() { 			public String getText(Object element) { 				return ((Person) element).surname; 			} 		}); 		column.setEditingSupport(new AbstractEditingSupport(v) { 			protected Object getValue(Object element) { 				return ((Person) element).surname; 			} 			protected void doSetValue(Object element, Object value) { 				((Person) element).surname = value.toString(); 			} 		}); 		 		new ColumnViewerSorter(v,column) { 			protected int doCompare(Viewer viewer, Object e1, Object e2) { 				Person p1 = (Person) e1; 				Person p2 = (Person) e2; 				return p1.surname.compareToIgnoreCase(p2.surname); 			} 			 		}; 		column = new TableViewerColumn(v, SWT.NONE); 		column.getColumn().setWidth(200); 		column.getColumn().setText("E-Mail"); 		column.getColumn().setMoveable(true); 		column.setLabelProvider(new ColumnLabelProvider() { 			public String getText(Object element) { 				return ((Person) element).email; 			} 		}); 		column.setEditingSupport(new AbstractEditingSupport(v) { 			protected Object getValue(Object element) { 				return ((Person) element).email; 			} 			protected void doSetValue(Object element, Object value) { 				((Person) element).email = value.toString(); 			} 		}); 		 		new ColumnViewerSorter(v,column) { 			protected int doCompare(Viewer viewer, Object e1, Object e2) { 				Person p1 = (Person) e1; 				Person p2 = (Person) e2; 				return p1.email.compareToIgnoreCase(p2.email); 			} 			 		}; 		Person[] model = createModel(); 		v.setInput(model); 		v.getTable().setLinesVisible(true); 		v.getTable().setHeaderVisible(true); 		cSorter.setSorter(cSorter, ColumnViewerSorter.ASC); 	} 	private Person[] createModel() { 		Person[] elements = new Person[4]; 		elements[0] = new Person("Tom", "Schindl", 				"tom.schindl@bestsolution.at"); 		elements[1] = new Person("Boris", "Bokowski", 				"Boris_Bokowski@ca.ibm.com"); 		elements[2] = new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com"); 		elements[3] = new Person("Wayne", "Beaton", "wayne@eclipse.org"); 		return elements; 	} 	private static abstract class ColumnViewerSorter extends ViewerComparator { 		public static final int ASC = 1; 		 		public static final int NONE = 0; 		 		public static final int DESC = -1; 		 		private int direction = 0; 		 		private TableViewerColumn column; 		 		private ColumnViewer viewer; 		 		public ColumnViewerSorter(ColumnViewer viewer, TableViewerColumn column) { 			this.column = column; 			this.viewer = viewer; 			this.column.getColumn().addSelectionListener(new SelectionAdapter() { 				public void widgetSelected(SelectionEvent e) { 					if( ColumnViewerSorter.this.viewer.getComparator() != null ) { 						if( ColumnViewerSorter.this.viewer.getComparator() == ColumnViewerSorter.this ) { 							int tdirection = ColumnViewerSorter.this.direction; 							 							if( tdirection == ASC ) { 								setSorter(ColumnViewerSorter.this, DESC); 							} else if( tdirection == DESC ) { 								setSorter(ColumnViewerSorter.this, NONE); 							} 						} else { 							setSorter(ColumnViewerSorter.this, ASC); 						} 					} else { 						setSorter(ColumnViewerSorter.this, ASC); 					} 				} 			}); 		} 		 		public void setSorter(ColumnViewerSorter sorter, int direction) { 			if( direction == NONE ) { 				column.getColumn().getParent().setSortColumn(null); 				column.getColumn().getParent().setSortDirection(SWT.NONE); 				viewer.setComparator(null); 			} else { 				column.getColumn().getParent().setSortColumn(column.getColumn()); 				sorter.direction = direction; 				 				if( direction == ASC ) { 					column.getColumn().getParent().setSortDirection(SWT.DOWN); 				} else { 					column.getColumn().getParent().setSortDirection(SWT.UP); 				} 				 				if( viewer.getComparator() == sorter ) { 					viewer.refresh(); 				} else { 					viewer.setComparator(sorter); 				} 				 			} 		} 		public int compare(Viewer viewer, Object e1, Object e2) { 			return direction * doCompare(viewer, e1, e2); 		} 		 		protected abstract int doCompare(Viewer viewer, Object e1, Object e2); 	} 	 	private class EditableFocusCellHighlighter extends FocusCellHighlighter { 		private ViewerCell oldCell; 		/** 		 * @param viewer 		 * the viewer 		 */ 		public EditableFocusCellHighlighter(ColumnViewer viewer) { 			super(viewer); 			hookListener(viewer); 		} 		private void markFocusedCell(Event event, ViewerCell cell) { 			GC gc = event.gc; 			gc.setBackground(SWTResourceManager.getColor(255, 255, 255)); 			gc.setForeground(SWTResourceManager.getColor(0, 0, 0)); 			gc.setLineWidth(4); 			int currentCol = event.index; 			Rectangle rect = ((TableItem)event.item).getBounds(currentCol); 			gc.drawRectangle(rect); 			event.detail &= ~SWT.FOCUSED; 			event.detail &= SWT.FocusOut; 			event.detail &= ~SWT.SELECTED; 		} 		private void removeSelectionInformation(Event event, ViewerCell cell) { 		} 		private void hookListener(final ColumnViewer viewer) { 			Listener listener = new Listener() { 				public void handleEvent(Event event) { 					if ((event.detail & SWT.SELECTED) > 0) { 						ViewerCell focusCell = getFocusCell(); 						ViewerRow row = focusCell.getViewerRow(); 						Assert 								.isNotNull(row, 										"Internal structure invalid. Item without associated row is not possible."); //$NON-NLS-1$ 						ViewerCell cell = row.getCell(event.index); 						if (focusCell == null || !cell.equals(focusCell)) { 							removeSelectionInformation(event, cell); 						} else { 							markFocusedCell(event, cell); 						} 					} 				} 			}; 			viewer.getControl().addListener(SWT.EraseItem, listener); 		} 		/** 		 * @param cell 		 * the cell which is colored 		 * @return the color 		 */ 		protected Color getSelectedCellBackgroundColor(ViewerCell cell) { 			return null; 		} 		/** 		 * @param cell 		 * the cell which is colored 		 * @return the color 		 */ 		protected Color getSelectedCellForegroundColor(ViewerCell cell) { 			return null; 		} 		/* 		 * (non-Javadoc) 		 * 		 * @see org.eclipse.jface.viewers.FocusCellHighlighter#focusCellChanged(org.eclipse.jface.viewers.ViewerCell) 		 */ 		protected void focusCellChanged(ViewerCell cell) { 			super.focusCellChanged(cell); 			// Redraw new area 			if (cell != null) { 				Rectangle rect = cell.getBounds(); 				int x = cell.getColumnIndex() == 0 ? 0 : rect.x; 				int width = cell.getColumnIndex() == 0 ? rect.x + rect.width 						: rect.width; 				// 1 is a fix for Linux-GTK 				cell.getControl().redraw(x, rect.y-1, width, rect.height+1, true); 			} 			if (oldCell != null) { 				Rectangle rect = oldCell.getBounds(); 				int x = oldCell.getColumnIndex() == 0 ? 0 : rect.x; 				int width = oldCell.getColumnIndex() == 0 ? rect.x + rect.width 						: rect.width; 				// 1 is a fix for Linux-GTK 				oldCell.getControl().redraw(x, rect.y-1, width, rect.height+1, true); 			} 			this.oldCell = cell; 		} 	} 	 	/** 	 * @param args 	 */ 	public static void main(String[] args) { 		Display display = new Display(); 		Shell shell = new Shell(display); 		shell.setLayout(new FillLayout()); 		new Snippet040TableViewerSorting(shell); 		shell.open(); 		while (!shell.isDisposed()) { 			if (!display.readAndDispatch()) 				display.sleep(); 		} 		display.dispose(); 	} }
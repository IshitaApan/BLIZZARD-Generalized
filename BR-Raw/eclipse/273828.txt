[Contributions] Regression (Widget is disposed) in CommandContributionItem

I seem to see a regression that is in some way related to the patch from bug 231304: Symptom: When invoking "Compare .. with each other" from the context menu (after selecting two source files in the package explorer) a dialog pops up saying "Widget is disposed". Background: This happens regarding a menu item which is contributed via a menu contribution with <visibleWhen checkEnabled="true"> </visibleWhen> Now opening the compare editor causes the following: BindingManager.fireBindingManagerChanged(BindingManagerEvent) line: 900 BindingManager.setActiveBindings(Map, Map, Map, Map) line: 2176 BindingManager.recomputeBindings() line: 1762 BindingManager.contextManagerChanged(ContextManagerEvent) line: 689 ContextManager.fireContextManagerChanged(ContextManagerEvent) line: 165 ContextManager.setEventCaching(boolean) line: 324 ContextManager.deferUpdates(boolean) line: 83 ContextAuthority.sourceChanged(int) line: 673 ContextAuthority(ExpressionAuthority).sourceChanged(int, String[]) line: 310 ContextAuthority(ExpressionAuthority).sourceChanged(int, Map) line: 290 WorkbenchSourceProvider(AbstractSourceProvider).fireSourceChanged(int, Map) line: 99 WorkbenchSourceProvider.checkActivePart(boolean) line: 409 WorkbenchSourceProvider.checkActivePart() line: 302 WorkbenchSourceProvider$1.partDeactivated(IWorkbenchPart) line: 249 PartListenerList$4.run() line: 117 SafeRunner.run(ISafeRunnable) line: 37 Platform.run(ISafeRunnable) line: 888 PartListenerList.fireEvent(SafeRunnable, IPartListener, IWorkbenchPart, String) line: 57 PartListenerList.firePartDeactivated(IWorkbenchPart) line: 115 PartService.firePartDeactivated(IWorkbenchPartReference) line: 238 PartService.setActivePart(IWorkbenchPartReference) line: 300 WWinPartService.updateActivePart() line: 131 WWinPartService.access$0(WWinPartService) line: 122 WWinPartService$WWinListener.partDeactivated(IWorkbenchPartReference) line: 50 PartListenerList2$4.run() line: 115 SafeRunner.run(ISafeRunnable) line: 37 Platform.run(ISafeRunnable) line: 888 PartListenerList2.fireEvent(SafeRunnable, IPartListener2, IWorkbenchPartReference, String) line: 55 PartListenerList2.firePartDeactivated(IWorkbenchPartReference) line: 113 PartService.firePartDeactivated(IWorkbenchPartReference) line: 242 PartService.setActivePart(IWorkbenchPartReference) line: 300 WorkbenchPagePartList.fireActivePartChanged(IWorkbenchPartReference, IWorkbenchPartReference) line: 57 WorkbenchPagePartList(PartList).setActivePart(IWorkbenchPartReference) line: 136 WorkbenchPage.setActivePart(IWorkbenchPart) line: 3524 WorkbenchPage.activate(IWorkbenchPart) line: 614 WorkbenchPage.busyOpenEditorBatched(IEditorInput, String, boolean, int, IMemento) line: 2865 WorkbenchPage.busyOpenEditor(IEditorInput, String, boolean, int, IMemento) line: 2762 At this point - and only since the patch from bug 231304 - the binding manager has a CommandContributionItem$1 as its listener and the call chain proceeds: CommandContributionItem.updateMenuItem() line: 556 CommandContributionItem.update(String) line: 511 CommandContributionItem.update() line: 500 CommandContributionItem$1.bindingManagerChanged(BindingManagerEvent) line: 904 method updateMenuItem() contains this snippet: boolean shouldBeEnabled = isEnabled(); if (item.getEnabled() != shouldBeEnabled) { ... Basically the first line disposes the menu item whereas the second line queries the widget, which throws the SWTException. The first line causes a call into our handler with code like this public void setEnabled(Object evaluationContext) { boolean enabled = computeEnablement(evaluationContext); setBaseEnabled(enabled); // happens to be false } The subsequent notification via AbstractHandler.fireHandlerChanged(HandlerEvent) line: 78 disposes the menu item. The second line calls into Widget.checkWidget() finding the widget disposed and boom. ---- All this does not happen in 3.4. Performing a forced return in CCI$1.bindingManagerChanged() successfully avoids the exception. I'm not sure if the actual bug here has been present and only by chance never surfaced before. Performing the same operations a second time produces a StackOverflowError, which I haven't analyzed further.
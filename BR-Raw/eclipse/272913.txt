[ActivityMgmt] Dynamically contributed activity extensions are not registering

+++ This bug was initially created as a clone of Bug #229993 +++ Created an attachment (id=98463) Fix Build ID: 3.4 M5 Steps To Reproduce: 1. Dynamically register an activity extension using the IExtensionRegistry.addContribution method. 2. Try to retrieve the activity and the pattern binding using the Activity APIs. Code to register: try { 	String ACTIVITY = "<plugin><extension point=\"org.eclipse.ui.activities\">"+ 	"<activity id=\"dynamic.activity\" name=\"Dynamic Activity\"/>"+ 	"<activityPatternBinding activityId=\"dynamic.activity\" pattern=\"dynamic.activity/.*\"/>"+ 	"<defaultEnablement id=\"dynamic.activity\"/>"+ 	"</extension></plugin>"; 	byte [] bytes = ACTIVITY.toString().getBytes("UTF-8"); 	InputStream is = new ByteArrayInputStream(bytes); 	IContributor contrib = ContributorFactoryOSGi.createContributor(Activator.getDefault().getBundle()); 	IExtensionRegistry registry = RegistryFactory.getRegistry( ); 	if (!registry.addContribution(is, contrib, false, null, null, null)) 		throw new RuntimeException(); } catch (UnsupportedEncodingException e) { 	e.printStackTrace(); } Code to lookup: IWorkbenchActivitySupport was = PlatformUI.getWorkbench( ).getActivitySupport( ); IActivity activity = was.getActivityManager().getActivity("dynamic.activity"); System.out.println(activity.isDefined()); More information: The problem seems to be with the load method of the org.eclipse.ui.internal.activities.ExtensionActivityRegistry class - it reuses the lists it creates to collect extensions - private void load() throws IOException { if (activityRequirementBindingDefinitions == null) { 			activityRequirementBindingDefinitions = new ArrayList(); 		} else { 			activityRequirementBindingDefinitions.clear(); 		} Further down the method - it compares the lists to (what it thinks is) the contents prior to the load method - if (!activityRequirementBindingDefinitions .equals(super.activityRequirementBindingDefinitions)) { super.activityRequirementBindingDefinitions = Collections .unmodifiableList(activityRequirementBindingDefinitions); activityRegistryChanged = true; } The Collections.unmodifiableList method just creates a wrapper around the list instance, and since the list instance is reused, it always ends up comparing the list instance to itself. I have attached a patch to the class that solves the problem.
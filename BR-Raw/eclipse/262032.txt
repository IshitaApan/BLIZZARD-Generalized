DeadlockDetector may create deadlock

Created attachment 123387 Stack dump The scenario is difficult to reproduce, but the core issue is that when a deadlock situation is detected, the lock which should get suspended can have depth == 0. This happens when the thread which held the lock is in the middle of releasing it (OrderedLock.doRelease()) so that the lock depth has already been set to 0, but it is blocked unregistering the locking thread from the DeadlockManager (see attached stack dump). In this situation, the LockState created for the suspended lock has depth == 0. When the lock is resumed later on, a lock is acquired and depth is reset to 0, but the lock will never be released again. This stale lock can easily trigger a real deadlock later on. I am attaching a stack dump of the situation when the deadlock is detected. The DeadlockManager graph at that time is: R/, P/panel, OrderedLock (490), Worker-46 : 1, 1, -1, Worker-45 : 0, -1, 0, main : -1, 0, 1, The value of the locksToSuspend variable is locksToSuspend	ISchedulingRule[1] (id=518)	 [0]	OrderedLock (id=513)	 	currentOperationThread	Thread (id=1)	 	depth	0	 	manager	LockManager (id=182)	 	number	490	 	operations	Queue (id=528)	 Note that the main thread is marked as waiting for the WorkspaceRoot (R/), while it is releasing the OrderedLock which is quite unexpected. This seems to be a consequence of the runAsyncMessages triggered while waiting for the rule.
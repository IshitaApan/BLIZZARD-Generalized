[Forms] ColumnLayout does not layout widgets correctly

I'm using eclipse 3.6M6 When given a large number of widgets >=150 (approx), ColumnLayout does not render them in the correct order as expected. In appears that the layout renders all widgets in columns (top to bottom) and 'overflows' into the next column until there is no space left to render another column (or the max columns set on the layout) Here's a test case to reproduce and a screenshot. The screenshot shows how the label order is screwed up at label numbered 22 (highlighted) where the layout breaks the rendering to the next column but comes back to rendering label number 155 in the same column. package eclipse.bugs; import org.eclipse.jface.layout.PixelConverter; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.forms.widgets.ColumnLayout; import org.eclipse.ui.forms.widgets.ColumnLayoutData; import org.eclipse.ui.forms.widgets.Hyperlink; public class ColumnLayoutTest { public static void main(String[] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setLayout(new GridLayout(1, false)); Composite composite = new Composite(shell, SWT.NONE); composite.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); ColumnLayout layout = new ColumnLayout(); layout.maxNumColumns = 20; layout.minNumColumns = 1; composite.setLayout(layout); // create 200 widgets, labels, hyperlinks, whatever for (int i = 1; i < 200; i++) { Hyperlink h = new Hyperlink(composite, SWT.NONE); // label.setLayoutData(); String text = i + " - Label"; h.setText(text); PixelConverter pixelConverter = new PixelConverter(h); int width = pixelConverter.convertWidthInCharsToPixels(text.length()); ColumnLayoutData layoutData = new ColumnLayoutData(width); h.setLayoutData(layoutData); } shell.setSize(600, 900); shell.open(); while (!shell.isDisposed()) { if (!display.readAndDispatch()) display.sleep(); } display.dispose(); } }
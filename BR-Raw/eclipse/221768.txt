[Viewers] Fix for bug 210747 causes NPE when parent is TreePath.EMPTY

Build ID: I20080207-1530 (3.4) Steps To Reproduce: We can across this problem with our debugger that wrappers the JDT debugger. To reproduce the problem you need a hidden launch. The exception that occurs is org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.NullPointerException) 	at org.eclipse.swt.SWT.error(SWT.java:3716) 	at org.eclipse.swt.SWT.error(SWT.java:3634) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:133) 	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3737) 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3374) 	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2392) 	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2356) 	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2222) 	at org.eclipse.ui.internal.Workbench$4.run(Workbench.java:474) 	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:288) 	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:469) 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149) 	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:106) 	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:193) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106) 	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:362) 	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:175) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:612) 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:564) 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:504) 	at org.eclipse.equinox.launcher.Main.run(Main.java:1251) 	at org.eclipse.equinox.launcher.Main.main(Main.java:1227) Caused by: java.lang.NullPointerException 	at org.eclipse.jface.viewers.CustomHashtable.hashCode(CustomHashtable.java:264) 	at org.eclipse.jface.viewers.CustomHashtable.get(CustomHashtable.java:236) 	at org.eclipse.jface.viewers.StructuredViewer.findItems(StructuredViewer.java:770) 	at org.eclipse.jface.viewers.AbstractTreeViewer.internalFindItem(AbstractTreeViewer.java:179) 	at org.eclipse.jface.viewers.AbstractTreeViewer.internalFindItems(AbstractTreeViewer.java:159) 	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRemove(AbstractTreeViewer.java:1902) 	at org.eclipse.jface.viewers.AbstractTreeViewer$6.run(AbstractTreeViewer.java:2134) 	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1365) 	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:390) 	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1328) 	at org.eclipse.jface.viewers.AbstractTreeViewer.remove(AbstractTreeViewer.java:2132) 	at org.eclipse.jface.viewers.AbstractTreeViewer.remove(AbstractTreeViewer.java:2186) 	at org.eclipse.debug.internal.ui.viewers.model.TreeModelContentProvider.handleRemove(TreeModelContentProvider.java:263) 	at org.eclipse.debug.internal.ui.viewers.model.ModelContentProvider.updateNodes(ModelContentProvider.java:625) 	at org.eclipse.debug.internal.ui.viewers.model.ModelContentProvider.updateNodes(ModelContentProvider.java:657) 	at org.eclipse.debug.internal.ui.viewers.model.ModelContentProvider$7.runInUIThread(ModelContentProvider.java:606) 	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:94) 	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) 	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:130) 	... 23 more More information: The problem is in the else block of AbstractTextViewer.internalRemove(Object[]) that was added for defect 210747. } else { 	// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210747 	Object parent = getParentElement(element); 	if (parent != null) { 	 Widget[] parentItems = internalFindItems(parent); 	 for (int j = 0; j < parentItems.length; j++) { 	 Widget parentItem = parentItems[j]; 	 if (parentItem instanceof Item) { 	 updatePlus((Item) parentItem, parent); 	 } 	 } 	} } The null pointer exception is a result of AbstractTextViewer.internalRemove(Object[]) passing an TreePath.EMPTY object to internalFindItems(). The TreePath.EMPTY object came from the preceding call to getParentElement(). The check for parent being null needs to be enhanced to also check for TreePath.EMPTY before proceeding. So if (parent != null) { should be changed to if (parent != null && parent != TreePath.EMPTY) {
Moving method referenced from inner type introduces compile errors

In M2: Given code: public class TestKindRegistry { 	public class TestKind { 		public String getPrecededKindIds() { 			return null; 		} 		public String getId() { 			return null; 		} 	} 	public ArrayList getAllKinds() { 		ArrayList items = new ArrayList(); 		Collections.sort(items, new Comparator() { 			public int compare(Object arg0, Object arg1) { 				TestKind kind0 = (TestKind) arg0; 				TestKind kind1 = (TestKind) arg1; 				if (precedes(kind0, kind1)) 					return -1; 				if (precedes(kind1, kind0)) 					return 1; 				return 0; 			} 		}); 		return items; 	} 	private boolean precedes(TestKind kind0, TestKind kind1) { 		// REF: move to kind0 		final String precededKindId = kind0.getPrecededKindIds(); 		String[] ids = precededKindId.split(","); //$NON-NLS-1$ 		for (int i = 0; i < ids.length; i++) { 			if (ids[i].equals(kind1.getId())) 				return true; 		} 		return false; 	} } Moving method "precedes" produces code: public class TestKindRegistry { 	public class TestKind { 		public String getPrecededKindIds() { 			return null; 		} 		public String getId() { 			return null; 		} 		boolean precedes(TestKindRegistry registry, TestKind kind1) { 			// REF: move to kind0 			final String precededKindId = getPrecededKindIds(); 			String[] ids = precededKindId.split(","); //$NON-NLS-1$ 			for (int i = 0; i < ids.length; i++) { 				if (ids[i].equals(kind1.getId())) 					return true; 			} 			return false; 		} 	} 	public ArrayList getAllKinds() { 		ArrayList items = new ArrayList(); 		Collections.sort(items, new Comparator() { 			public int compare(Object arg0, Object arg1) { 				TestKind kind0 = (TestKind) arg0; 				TestKind kind1 = (TestKind) arg1; 				if (kind0.precedes(this, kind1)) 					return -1; 				if (kind1.precedes(this, kind0)) 					return 1; 				return 0; 			} 		}); 		return items; 	} } Not only is the first parameter for precedes unnecessary, but it should be TestKindRegistry.this
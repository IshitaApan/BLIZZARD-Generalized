[CommonNavigator] [Java] Proposed Java extension for Common Navigator

This PR is to track Code Review comments specifically related to the Java extension for the Common Navigator. The original comments from Dirk were posted to bug 116460 comment 2. I've copied those comments to refer to them in this response for the conveneince of reviewers and myself. <dirk> Enclosed a first cut of the code review I did. I tried to only list extensions to the already present comments. More to follow tomorrow. Coding style: We don't use aVariable as a name in Eclipse at all and IMO we shouldn't start using this pattern (its Smalltalk, which I like, but not Java). <mde>Fixed in new version.</mde> NavigatorContent extension point: The extension point lists a lot of different classes (content provider, label provider, ....). Wouldn't it make it easier for clients to only have one class to implement which provides hook methods to actually create the different providers, filters, sorters, .... Something like public abstract class CommonNavigatorContent { public abstract ILabelProvider getLabelProvider(); <== required. public IViewerSorter getSorter() { <== optional return null; } } <mde> The original approach used by the "General Purpose" navigator that we picked up used this style. In practice, we found it to generate more code than necessary. More often than not, clients had most of their content ready to go (content providers, label providers, filters, sorters, etc) because they were migrating from existing viewers. There was no way to minimize the impact for extensions built from scratch, of course. As a result, we migrated towards making the extension more loosely coupled. Architecturally, the instantiated contributions from each extension are managed by a single unit (which coincidentally has the same name as did the original "INavigatorContentExtension" required of extensions). This makes it easier to provide a fail-safe layer between the framework components and extensions who behave errantly -- unfound classes, invalid extension specifications, or what have you. Whenever an object cannot be instantiated from an extension, a "Skeleton" is created in its place with a default, no-op implementation. This also prevents a proliferation of null-checking. </mde> It is still open to me how we deal with sync versus async exec when updating the common navigator. The package explorer content provider uses async exec whereas the resource navigator uses sync exec. IMO the two can't be mixed in one viewer without asking for trouble. <mde> My recommendation is to use UIJobs where possible and async as a fall back. I tend to think that sync should be avoided where the navigational type viewers are at work; and should therefore be avoided unless absolutely necesary. </mde> How do we deal with DnD and context menus on the top level project elements. We shouldn't load any code when the user hovers over a project during DnD nor when he opens the context menu. So for these two we need at least a separate extension point. <mde>For context menus, clients may take advantage of objectContributions to minimize the impact of loading code. However, for some clients they require programmatic construction of a menu (for instances, cases where the submenu options vary based on the contents of a folder). Therefore, opening the context menu can lead to loading code. Similarly, in order to configure the IActionBars (which can change on each selection, unlike other viewers), the available action providers for a particular element must be loaded and allowed to contribute. We can optimize this to allow clients to indicate if they contribute to the IActionBars to limit the loading, but sometimes this will still be required.</mde> DnD: Why do we need to serialize all the selection during DnD. In JDT/UI we followed a more simple approach. Inside the same VM we simply pass the selection around without actually transforming them into bytes and back. Between applications we only support file/string transfers. This proofed to be sufficient. <mde>The DND API will be finalized this coming week. The original design allowed for clients to specify their own serialization formats (based on the Gadget example article for DND). However, I am in complete agreement that LocalSelectionTransfer and FileTransfer are the minimum set and these are likeyl to be the only supported transfer types (ResourceTransfer is up for debate due to the RCP dependency). </mde> Package explorer extension: I am not sure anymore if we should hack the existing content provider to support the common navigator or if we start having a new one (which might share some code with the current one). <mde>The latest version of the patch only minimally affects the existing PackageExplorerContentProvider (removing the dependency to PackageExplorerPart). I will leave it to you to decide if this makes sense. .</mde> Why do we need a class MementoFlags. At least 80% of the constants defined here are independent of JDT and should come with the navigator framework. Same for IExtensionStateConstants. <mde>The MementoFlags class was removed and IExtensionStateConstants was culled. I'll leave it to you to determine whether you want to merge these constants elsewhere in the JDT extension.</mde> Some of the code in the package explorer extension is referring to internal common navigator code. Are we missing API here (for example references to INavigatorContentService) <mde>All internal references have been removed! (talk about improvement ;)</mde> I still don't get the hack with the fIncludeResources in the StandardJavaElementCOntentProvider. Sometimes resources are filters (for example below package fragment roots) sometimes not (below packages). In general I still think that we need a different solution here for what every problem the Common Navigator tries to address. If the Navigator asked the Java extension to render the content of a Java project the extension should do its best to do so and not leaving parts of the children out and hoping that some other extension adds them (what if the extensions isn't available). Currently adding files to source folders simply results in not showing these files at all. And filtering duplicates at the end using something like the JavaResourceDuplicationFilter is strange as well. If some other common navigator extension wants to render Java project differently it should override the Java extension and should have means to load the Java extension and to delegate to it. The new extension can then filter or restructure the content as it would like to do. <mde>After our last discussion I agreed to provide this pipeline support. I have provided the initial API and begun the implementation (viewer intercepts not ready as of right now, will be soon). The updated version of the Java extension takes advantage of this new API.</mde> </dirk>
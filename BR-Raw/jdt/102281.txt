[call hierarchy] shouldn't be stopped by anonymous inner classes

Here's a common scenario for me: I have a method deep in the innards of Eclipse, and I'm curious about the paths through which it might be called. I open call hierarchy on it, and search through the tree at leisure. At some point, I get stopped, because I come across a method like TestRunnerViewPart.showFailure: 	private void showFailure(final TestRunInfo failure) { 		postSyncRunnable(new Runnable() { 			public void run() { 				if (!isDisposed()) 					fFailureTrace.showFailure(failure); 			} 		});		 	} the caller of fFailureTrace.showFailure is Runnable.run. However, it's useless to expand that call hierarchy node, because it will show me every possible invocation of Runnable.run in the whole system (there are 88, of which only one is actually relevant). What I'm really wanting to do is to continue my search up through TestRunnerViewPart.showFailure. To do so, I must open up a new call hiearchy search, which consigns my old, carefully built-up search tree to the History List. One solution would be to actually employ some context-sensitivity in the call hierarchy analysis. This is probably not a good idea in terms of cost/benefit analysis. A better solution, for my money, would be to have a new option on the context menu on a node in the Call Hierarchy: "Expand with constructors". This would let me expand thusly (edited for clarity, I hope) showFailure(TestRunInfo) - ...FailureTrace run() - ...TestRunnerViewPart.showFailure(...).new Runnable() {...} [constructors] Runnable() {...} showFailure(TestRunInfo) - ...TestRunnerViewPart 	testReran(...) - ...TestRunnerViewPart 	handleTestSelected(TestRunInfo) - ...TestRunnerViewPart (2 matches)
[implementation] AbstractMarkerAnnotationModel.updateMarker doesn't maintain Marker length

Using 3.0M5. I hope this is clear what my problem is. The problem I'm running into is that when I use the updateMarker(3 args) function to force a Marker up to date, the resource change listener isn't disabled. So the BasicMarkerUpdater sets the Marker CHAR_START, which causes the listener to be invoked, which causes the Position length to be recalculated based on the new CHAR_START and the old CHAR_END. Then the BasicMarkerUpdater attempts to set the new CHAR_END, but it uses the Position length, which is wrong because it was just set when the start was adjusted. The results is that the Marker length gets decreased when the Marker is moved forward, and increased when the Marker is moved backward. The updateMarker(3 args) version is public, so I assume that this should work as expected. Possible solution: The updateMarkers(IDocument) method disables the listener with listenToMarkerChanges(false) before iterating through all the Markers to update them. I think that the updateMarker(IMarker,IDocument,Position) method needs to do something similar, although some care must be taken since it is called by the updateMarkers(IDocument) method. Snippet: (I'm attempting to update only my markers when an edit occurs) public void adjustReadOnlyMarkersForEdit() { IDocumentProvider provider=editor.getDocumentProvider(); IAnnotationModel annotationModel=provider.getAnnotationModel (editor.getEditorInput()); AbstractMarkerAnnotationModel markerAnnotationModel= (AbstractMarkerAnnotationModel)annotationModel; try { ITextViewer viewer=(ITextViewer)editor.getAdapter (ITextOperationTarget.class); IDocument doc=viewer.getDocument(); // ((AbstractMarkerAnnotationModel)annotationModel).updateMarkers (viewer.getDocument()); //*************This statement works for (Iterator iter= mReadOnlyAnnotations.iterator(); iter.hasNext ();) 			{ 				EditorReadOnlyMarker element= (EditorReadOnlyMarker) iter.next(); markerAnnotationModel.updateMarker (element.mStartMarker.getMarker(),doc,markerAnnotationModel.getMarkerPosition (element.mStartMarker.getMarker())); //*********This statement incorrectly updates the marker } } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } }
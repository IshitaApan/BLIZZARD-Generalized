FunctionMapperImpl.Function throws a NPE in certain circumstances

In FunctionMapperImpl.Function it is possible for writeExternal to fail if the class has just been de-serialised and is then serialised again. If you look at writeExternal: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF((this.prefix != null) ? this.prefix : ""); out.writeUTF(this.localName); out.writeUTF(this.m.getDeclaringClass().getName()); out.writeUTF(this.m.getName()); out.writeObject(ReflectionUtil.toTypeNameArray( this.m.getParameterTypes())); } you can see that it externalises the function to be invoked by using the reference to the Method itself. If you look at readExternal however: public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.prefix = in.readUTF(); if ("".equals(this.prefix)) this.prefix = null; this.localName = in.readUTF(); this.owner = in.readUTF(); this.name = in.readUTF(); this.types = (String[]) in.readObject(); } You can see that it doesn't restore the Method after deserialisation. The method is restored if it is accessed, however if it's not and then serialisation is performed writeExternal will throw a NPE (as m is still null). The fix is to either get the method to be reconstructed as soon as deserialisation completes - or perhaps to be a bit more efficient, in writeExternal change it such that if m is null it externalises using the components of the method: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF((this.prefix != null) ? this.prefix : ""); out.writeUTF(this.localName); if (m == null) { out.writeUTF(this.owner); out.writeUTF(this.name); out.writeObject(this.types); } else if (this.m != null) { out.writeUTF(this.m.getDeclaringClass().getName()); out.writeUTF(this.m.getName()); out.writeObject(ReflectionUtil.toTypeNameArray( this.m.getParameterTypes())); } }
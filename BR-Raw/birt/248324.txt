Example SWTLiveViewer crashes after a few minutes

In response to a request on the BIRT Newgroups. User had requested a more "robust" example of using the BIRT chart engine in a live example after the SWTLiveChart example crashed after a few minutes. I looked into the code and noticed that the paint method does not dispose of any of the resources it allocates, such as the GC objects and Image objects. After adding in the proper dispose methods, the example seems to run fine. However, the user notates that the example is still extremely slow when the screen is resized. I have also encountered the same issue. He also notated that there are extranous and unnecessary calls in the refresh method. Message thread pasted below: ----------------------------------------------------------- John Ward wrote: > Michael, > > I looked at the example, and your right, it does not dispose of the SWT widgets properly, causing it to run out of resources a few minutes into the run. I rewrote the example, modified it to use 20 data points, refresh every 50 miliseconds (roughly 20 times a second), and added in the calls to dispose of the graphics contexts after render. I left it running for about 2 hours and didnt have any crashes, run out of resources or handles, or run out of heap space. > > The following example was run with the BIRT runtime vs 2.2.1, and the example was added in the BIRT source code plugin project org.eclipse.birt.chart.examples, under the org.eclipse.birt.chart.examples.api.viewer package. I ran it in Eclipse 3.3.1.1, and outside of there not being a proper close method to end the application, I didn't run across any issues. > > Again though, the Chart Engine API isn't my area of expertise, so Jason would have to comment more on if the Chart Engine will do what you want. > > John > > /*********************************************************************** > * Copyright (c) 2004, 2007 Actuate Corporation. > * All rights reserved. This program and the accompanying materials > * are made available under the terms of the Eclipse Public License v1.0 > * which accompanies this distribution, and is available at > * http://www.eclipse.org/legal/epl-v10.html > * > * Contributors: > * Actuate Corporation - initial API and implementation > ***********************************************************************/ > > package org.eclipse.birt.chart.examples.api.viewer; > > import org.eclipse.birt.chart.api.ChartEngine; > import org.eclipse.birt.chart.device.IDeviceRenderer; > import org.eclipse.birt.chart.examples.api.script.JavaScriptViewer; > import org.eclipse.birt.chart.exception.ChartException; > import org.eclipse.birt.chart.factory.GeneratedChartState; > import org.eclipse.birt.chart.factory.Generator; > import org.eclipse.birt.chart.log.ILogger; > import org.eclipse.birt.chart.log.Logger; > import org.eclipse.birt.chart.model.Chart; > import org.eclipse.birt.chart.model.ChartWithAxes; > import org.eclipse.birt.chart.model.attribute.AxisType; > import org.eclipse.birt.chart.model.attribute.Bounds; > import org.eclipse.birt.chart.model.attribute.IntersectionType; > import org.eclipse.birt.chart.model.attribute.LineAttributes; > import org.eclipse.birt.chart.model.attribute.LineStyle; > import org.eclipse.birt.chart.model.attribute.Marker; > import org.eclipse.birt.chart.model.attribute.MarkerType; > import org.eclipse.birt.chart.model.attribute.Position; > import org.eclipse.birt.chart.model.attribute.RiserType; > import org.eclipse.birt.chart.model.attribute.TickStyle; > import org.eclipse.birt.chart.model.attribute.impl.BoundsImpl; > import org.eclipse.birt.chart.model.attribute.impl.ColorDefinitionImpl; > import org.eclipse.birt.chart.model.component.Axis; > import org.eclipse.birt.chart.model.component.Series; > import org.eclipse.birt.chart.model.component.impl.SeriesImpl; > import org.eclipse.birt.chart.model.data.NumberDataSet; > import org.eclipse.birt.chart.model.data.SeriesDefinition; > import org.eclipse.birt.chart.model.data.TextDataSet; > import org.eclipse.birt.chart.model.data.impl.NumberDataSetImpl; > import org.eclipse.birt.chart.model.data.impl.SeriesDefinitionImpl; > import org.eclipse.birt.chart.model.data.impl.TextDataSetImpl; > import org.eclipse.birt.chart.model.impl.ChartWithAxesImpl; > import org.eclipse.birt.chart.model.layout.Legend; > import org.eclipse.birt.chart.model.layout.Plot; > import org.eclipse.birt.chart.model.type.BarSeries; > import org.eclipse.birt.chart.model.type.LineSeries; > import org.eclipse.birt.chart.model.type.impl.BarSeriesImpl; > import org.eclipse.birt.chart.model.type.impl.LineSeriesImpl; > import org.eclipse.birt.core.framework.PlatformConfig; > import org.eclipse.swt.SWT; > import org.eclipse.swt.events.PaintEvent; > import org.eclipse.swt.events.PaintListener; > import org.eclipse.swt.graphics.GC; > import org.eclipse.swt.graphics.Image; > import org.eclipse.swt.graphics.Rectangle; > import org.eclipse.swt.layout.GridData; > import org.eclipse.swt.layout.GridLayout; > import org.eclipse.swt.widgets.Composite; > import org.eclipse.swt.widgets.Display; > import org.eclipse.swt.widgets.Shell; > > public class SwtLiveChartViewer extends Composite implements PaintListener { > > private IDeviceRenderer idr = null; > > private Chart cm = null; > > private GeneratedChartState gcs = null; > > public static SwtLiveChartViewer c3dViewer; > > /** > * Used in building the chart for the first time > */ > private boolean bFirstPaint = true; > > private static ILogger logger = Logger.getLogger(JavaScriptViewer.class > .getName()); > > /** > * execute application > * > * @param args > */ > public static void main(String[] args) { > Display display = Display.getDefault(); > Shell shell = new Shell(display); > shell.setSize(600, 400); > shell.setLayout(new GridLayout()); > > c3dViewer = new SwtLiveChartViewer(shell, SWT.NO_BACKGROUND); > c3dViewer.setLayoutData(new GridData(GridData.FILL_BOTH)); > c3dViewer.addPaintListener(c3dViewer); > > shell.open(); > while (!shell.isDisposed()) { > if (!display.readAndDispatch()) > display.sleep(); > } > display.dispose(); > } > > /** > * Constructor > */ > SwtLiveChartViewer(Composite parent, int style) { > super(parent, style); > > try { > PlatformConfig config = new PlatformConfig(); > config.setProperty("STANDALONE", "true"); //$NON-NLS-1$ //$NON-NLS-2$ > idr = ChartEngine.instance(config).getRenderer("dv.SWT");//$NON-NLS-1$ > } catch (ChartException pex) { > logger.log(pex); > } > > cm = createLiveChart(); > > } > > public static final Chart createLiveChart() { > ChartWithAxes cwaBar = ChartWithAxesImpl.create(); > > // Plot > cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE()); > Plot p = cwaBar.getPlot(); > p.getClientArea().setBackground( > ColorDefinitionImpl.create(255, 255, 225)); > > // Legend > Legend lg = cwaBar.getLegend(); > LineAttributes lia = lg.getOutline(); > lg.getText().getFont().setSize(16); > lia.setStyle(LineStyle.SOLID_LITERAL); > lg.getInsets().setLeft(10); > lg.getInsets().setRight(10); > > // Title > cwaBar.getTitle().getLabel().getCaption().setValue("Live Chart Demo");//$NON-NLS-1$ > > // X-Axis > Axis xAxisPrimary = cwaBar.getPrimaryBaseAxes()[0]; > > xAxisPrimary.setType(AxisType.TEXT_LITERAL); > xAxisPrimary.getOrigin().setType(IntersectionType.VALUE_LITERAL); > xAxisPrimary.getOrigin().setType(IntersectionType.MIN_LITERAL); > > xAxisPrimary.getTitle().getCaption().setValue("Category Text X-Axis");//$NON-NLS-1$ > xAxisPrimary.setTitlePosition(Position.BELOW_LITERAL); > > xAxisPrimary.getLabel().getCaption().getFont().setRotation(75); > xAxisPrimary.setLabelPosition(Position.BELOW_LITERAL); > > xAxisPrimary.getMajorGrid().setTickStyle(TickStyle.BELOW_LITERAL); > xAxisPrimary.getMajorGrid().getLineAttributes().setStyle( > LineStyle.DOTTED_LITERAL); > xAxisPrimary.getMajorGrid().getLineAttributes().setColor( > ColorDefinitionImpl.create(64, 64, 64)); > xAxisPrimary.getMajorGrid().getLineAttributes().setVisible(true); > > // Y-Axis > Axis yAxisPrimary = cwaBar.getPrimaryOrthogonalAxis(xAxisPrimary); > > yAxisPrimary.getLabel().getCaption().setValue("Price Axis");//$NON-NLS-1$ > yAxisPrimary.getLabel().getCaption().getFont().setRotation(37); > yAxisPrimary.setLabelPosition(Position.LEFT_LITERAL); > > yAxisPrimary.setTitlePosition(Position.LEFT_LITERAL); > yAxisPrimary.getTitle().getCaption().setValue("Linear Value Y-Axis");//$NON-NLS-1$ > > yAxisPrimary.setType(AxisType.LINEAR_LITERAL); > > yAxisPrimary.getMajorGrid().setTickStyle(TickStyle.LEFT_LITERAL); > yAxisPrimary.getMajorGrid().getLineAttributes().setStyle( > LineStyle.DOTTED_LITERAL); > yAxisPrimary.getMajorGrid().getLineAttributes().setColor( > ColorDefinitionImpl.RED()); > yAxisPrimary.getMajorGrid().getLineAttributes().setVisible(true); > > // X-Series > Series seCategory = SeriesImpl.create(); > SeriesDefinition sdX = SeriesDefinitionImpl.create(); > xAxisPrimary.getSeriesDefinitions().add(sdX); > sdX.getSeries().add(seCategory); > > // Y-Series (1) > BarSeries bs1 = (BarSeries) BarSeriesImpl.create(); > bs1.setSeriesIdentifier("Unit Price");//$NON-NLS-1$ > bs1.setRiserOutline(null); > bs1.setRiser(RiserType.RECTANGLE_LITERAL); > > // Y-Series (2) > LineSeries ls1 = (LineSeries) LineSeriesImpl.create(); > ls1.setSeriesIdentifier("Quantity");//$NON-NLS-1$ > ls1.getLineAttributes().setColor(ColorDefinitionImpl.GREEN()); > for (int i = 0; i < ls1.getMarkers().size(); i++) { > ((Marker) ls1.getMarkers().get(i)).setType(MarkerType.BOX_LITERAL); > } > ls1.setCurve(true); > > SeriesDefinition sdY = SeriesDefinitionImpl.create(); > yAxisPrimary.getSeriesDefinitions().add(sdY); > sdY.getSeriesPalette().shift(-1); > sdY.getSeries().add(bs1); > sdY.getSeries().add(ls1); > > // Update data > updateDataSet(cwaBar); > return cwaBar; > } > > static final void updateDataSet(ChartWithAxes cwaBar) { > // Associate with Data Set > TextDataSet categoryValues = TextDataSetImpl.create(sa); > NumberDataSet seriesOneValues = NumberDataSetImpl.create(da1); > NumberDataSet seriesTwoValues = NumberDataSetImpl.create(da2); > > // X-Axis > Axis xAxisPrimary = cwaBar.getPrimaryBaseAxes()[0]; > SeriesDefinition sdX = (SeriesDefinition) xAxisPrimary > .getSeriesDefinitions().get(0); > ((Series) sdX.getSeries().get(0)).setDataSet(categoryValues); > > // Y-Axis > Axis yAxisPrimary = cwaBar.getPrimaryOrthogonalAxis(xAxisPrimary); > SeriesDefinition sdY = (SeriesDefinition) yAxisPrimary > .getSeriesDefinitions().get(0); > ((Series) sdY.getSeries().get(0)).setDataSet(seriesOneValues); > ((Series) sdY.getSeries().get(1)).setDataSet(seriesTwoValues); > } > > // Live Date Set > private static final String[] sa = { "One", "Two", "Three", "Four", "Five",//$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$//$NON-NLS-5$ > "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "twelve", "thirteen", "fourteen", "fifteen", "sizeteen", "seventeen", "Eighteen", "nineteen", "twenty" };//$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$//$NON-NLS-5$ > private static final double[] da1 = { 56.99, 352.95, -201.95, 299.95, > -95.95, 25.45, 129.33, -26.5, 43.5, 122, 20, 35, 59, 105, 150, -37, -65, -99, > -145, -185 }; > > private static final double[] da2 = { 20, 35, 59, 105, 150, -37, -65, -99, > -145, -185, 56.99, 352.95, -201.95, 299.95, > -95.95, 25.45, 129.33, -26.5, 43.5, 122 }; > > static final void scrollData(ChartWithAxes cwa) { > // Scroll the bar (Y) series > double dTemp = da1[0]; > for (int i = 0; i < da1.length - 1; i++) { > da1[i] = da1[i + 1]; > } > da1[da1.length - 1] = dTemp; > > // Scroll the line (Y) series > dTemp = da2[0]; > for (int i = 0; i < da2.length - 1; i++) { > da2[i] = da2[i + 1]; > } > da2[da2.length - 1] = dTemp; > > // Scroll X series > String sTemp = sa[0]; > for (int i = 0; i < sa.length - 1; i++) { > sa[i] = sa[i + 1]; > } > sa[sa.length - 1] = sTemp; > > updateDataSet(cwa); > } > > /* > * (non-Javadoc) > * > * @see org.eclipse.swt.events.PaintListener#paintControl(org.eclipse.swt.events.PaintEvent) > */ > public final void paintControl(PaintEvent e) { > Rectangle d = this.getClientArea(); > Image imgChart = new Image(this.getDisplay(), d); > GC gcImage = new GC(imgChart); > idr.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, gcImage); > > Bounds bo = BoundsImpl.create(0, 0, d.width, d.height); > bo.scale(72d / idr.getDisplayServer().getDpiResolution()); > > Generator gr = Generator.instance(); > > try { > gcs = gr.build(idr.getDisplayServer(), cm, bo, null, null, null); > } catch (ChartException ce) { > ce.printStackTrace(); > } > > if (bFirstPaint) { > bFirstPaint = false; > // Timer t = new Timer( ); > // t.schedule( new ChartRefresh( ), 1000 ); > > new Thread(new Runnable() { > public void run() { > while (true) { > try { > Thread.sleep(50); > } catch (Exception e) { > } > Display.getDefault().asyncExec(new Runnable() { > public void run() { > chartRefresh(); > } > }); > } > } > }).start(); > > } > try { > gr.render(idr, gcs); > GC gc = e.gc; > gc.drawImage(imgChart, d.x, d.y); > imgChart.dispose(); > gcImage.dispose(); > gc.dispose(); > } catch (ChartException ex) { > ex.printStackTrace(); > } > > } > > /* > * (non-Javadoc) > * > * @see org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent) > */ > private void chartRefresh() { > > final Generator gr = Generator.instance(); > scrollData((ChartWithAxes) cm); > > // Refresh > try { > gr.refresh(gcs); > } catch (ChartException ex) { > ex.printStackTrace(); > } > redraw(); > > } > } > > > Michael Scharf wrote: >> John, >> >> I don't need updates 10 times a second. I tested this to >> find the limits of the BIRT charting. And for the test that >> eats up all resources, I used the (almost unmodified) example from >> http://dev.eclipse.org/newslists/news.eclipse.birt/msg25051.html >> with about 20 data-points. >> >> The code contains the following in paintControl(...): >> Image imgChart = new Image( this.getDisplay( ), d ); >> GC gcImage = new GC( imgChart ); >> >> but neither disposes the GC nor the Image. Increasing the >> java heap does not help with this kind of problems, because >> it leaks resources outside the java VM: >> http://www.eclipse.org/articles/swt-design-2/swt-design-2.html >> >> So, I did not even try thousands of data points to get those problems. >> I think the SwtLiveChartViewer example would need a redesign to >> dispose resources (simply disposing the resources at the end of >> the method does not work). >> >> I wonder if there is a more robust example of a live chart, or >> if live charting is not really supported or the example is a hack. >> I would have expected a live chart in the "Chart Samples" Viewer. >> I tried to put the SwtLiveChartViewer into the example viewer, >> but it turns out to be quite difficult, because the update needs >> a pointer to GeneratedChartState, which somehow seems to be tied >> to the GC. It seems to me I would need to have some more in >> depth knowledge to figure out a clean way how this is propagated >> to the runnable that does the update. I was hoping for an out of the >> box example here. >> >> I need 10k of data points, because my application tracks some >> values with a sample rate of 1 sec. After 3h I have 10k data >> points. If I have 10 variables I want to show in a line chart, >> as different lines, I get 10k data points after 15 min.... >> If I have 5 charts running I hit the 10k after 3 min. >> >> 10 charts shown in different views, refreshed once a sec, is >> about the same as 1 chart updated 10 times a sec (that's why I >> tried 100ms update time). >> >> What I wanted to do is some sanity testing to see if BIRT charting >> would be an option for our application.... >> >> More than 15 years ago I wrote a charting engine in C (for X11) >> and it was easily capable of displaying several 100k data points >> updating 20 times/sec. I did 3d charts with lines, dots and chars, >> which could be rotated and scaled at runtime with no 3d hardware >> acceleration. (I was actually implementing a subset of OpenGL >> directly on X11). >> >> So, I was hoping that with todays computers live charting would be >> blastingly fast.... >> >> >> Michael >> >>> I would try to increase the amount of memory your using in your VM using the -X options in Java, or try to add a manual garbage collection. Without seeing the code or knowing the context of the app, off the top of my head I would say that 10k data points is a lot, and the refresh rate is too quick. Not sure why you would need a refresh 10 times a second, but without knowing the app, I couldn't say for sure. Anything beyond that Jason would need to comment on. >>> >>> John >>> >>> Michael Scharf wrote: >>>> Hi, >>>> >>>> I am investigation if I can use BIRT to show >>>> live data (ten thousands of data points). >>>> >>>> I found the SwtLiveChartViewer example >>>> http://dev.eclipse.org/newslists/news.eclipse.birt/msg25051.html >>>> but this leaks SWT resources (it kills my windows >>>> machine if I set the refresh time to 100 ms and >>>> run it for a minute or two). >>>> >>>> Is there any more robust example of a live chart or is >>>> live charting not really supported by BIRT. >>>> >>>> Michael
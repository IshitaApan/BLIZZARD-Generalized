Spinner: getSelection() during modify event should return new value (enable dynamic behaviour)

This is a cleaned-up version of bug 94065. SWT-win32, v3137 (3.1RC2) [The basics] - The selection of the spinner widget (the numeric value) can be queried by calling getSelection() - When the text in the spinner changes, a modify event is fired. This can happen if * The user clicks on the up/down button (or uses the arrow keys) * The user types or pastes some digits or clears the text [The problem] When a modify event occurs, you will want to know the new selection value. In order to get it you call getSelection() inside the modifyText handler. If the event has occurred because the user has clicked on the up/down button or has used the arrow up/down keys, there is no problem; getSelection() will return the expected value in this case. If, however, the event was issued due to the user typing (or pasting) some digits, the situation is different. The expectation here is that getSelection() would return the number represented by the newly-typed text, but this does not happen. Instead the old value is returned. [An example] Let's say the spinner is set to 50. The user selects the text "50" and replaces it by typing 123. Expected events: - modify event, getSelection() = 1 - modify event, getSelection() = 12 - modify event, getSelection() = 123 Actual events: - modify event, getSelection() = 50 - modify event, getSelection() = 50 - modify event, getSelection() = 50 As you can see, three notifications that the text has changed are issued but there is no way of actually retrieving that text or, more importantly, the number it represents. In other words, the events are pretty useless. Only once/if the user presses Return or the spinner loses focus will a modify event with the right selection be fired. [Why this is a problem] When some property (selection, text, ...) of widget A changes, you may want to update other widgets (B, C, ...) to immediately reflect this change in some way. The spinner widget is no different here. For example, if you have A) a spinner that lets the user choose the font size and B) a font preview canvas, you will want to update B when A changes. This means, if the user types "12" into the spinner, you will want to show a 12pt sample text in the preview canvas. Right now, this is not possible. Typing "12" is not enough, the user would have to press Return afterwards or move the focus to some other widget. [Snippet] For a demonstration of the above, use the code in comment #1. Two things to note about the case portrayed by the snippet: 1. The user may expect the preview pane to be dynamically updated while he's typing a new value and may be irritated if this does not happen. (I know I was.) Users know that they have to press Return when the drop down box of a combo is open but do they know they need to press Return in an SWT spinner? Or Tab, then Shift+Tab as a workaround? 2. Most spinner widgets can be found in dialogs, as is the case here. Pressing Return in a dialog will activate the default button which will usually close the dialog. This is not desirable here. The user wants to see what the chosen font size will look like (and may want to revise his decision after seeing the preview), not submit the dialog. You would have to veto the traversal event to prevent this, but then again, I do not recall having seen regular spinners in Windows dialogs that do this. [Why this differs from the behaviour of native Windows spinners] In general, it is not necessary to press Return for the value to become valid in a Windows spinner. For an example of "dynamic updates" being possible, compare the behaviour of the spinner in the given snippet with the one controlling the item size in Display->Appearance->Advanced (Windows Control Panel). If you enter a new value for, say, the title bar size, you will get immediate visual feedback in the preview pane. [Requested fix] Make getSelection() always return the current (new) selection during a modify event and at all other times, at least on Windows. [What if the typed text does not represent a valid number?] - If the text is empty, return the minimum. - If the text contains a number that is less than the minimum, return the minimum. - If the text contains a number that is greater than the maximum, return the maximum. [Some history] In 3.1M5, the behaviour was actually as expected (and requested here). So why has it been changed? Felipe Heidrich explains: "[...] what you described is exactly how win32 behaves. The thing is: I couldn't get Spinner on the other platforms to behave this way (specially GTK). The API/behaviour has to be consistent across platforms. The current behaviour might not be great but it is consistent across all our platforms and it is also consistent with our Combo box." My answer: "I cannot comment on the GTK spinner at all but considering the fact that API-wise it does not seem like that big an issue, would it be unthinkable to just declare this "platform behaviour" (which it is) instead of sacrificing usability for all Windows users (who probably still outnumber the GTK folks)? I promise I won't file a "[consistency]" bug if you do this..." So what this boils down to is: do not make the spinner on Windows hard to use (and non-native in behaviour) in dynamic updating scenarios just because of some quirks on other platforms. If the platform convention is that you have to press Return after typing a spinner value on GTK (I couldn't check this; not sure how they handle the dialog case) but not on Windows, then I think SWT should respect this. [getText() to the rescue?] It was suggested that if the policy of getSelection() absolutely could not be changed, then at least a getText() method should be provided so it would be possible to retrieve the raw text and do the parsing yourself. I agree that this would be much better than not being able to find out the new selection at all. However, I think it's not the right way as long as there is still hope of actually fixing getSelection(). The number parsing functionality of the spinner widget should not have to be replicated in client code.
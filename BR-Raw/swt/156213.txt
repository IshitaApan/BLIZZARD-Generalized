BDI: Styledetxt setOrientation does not work, on the fly

I am trying to use the setOrientation function on the styledText widget. When using it, it does not show the carret at the correct position, and when changing from RTL -> LTR and back it draws the text on both sides (try selecting the text and on the othr side it is hidden , until u highlight it). In the example I add 3 styled texts. 1. initialized as LTR, 2. initialized as RTL 3. initialized without the flag A listener is put in place so when Ctrl+Shift is pressed, the GO changes. in widgets 1,2 the whole widget is disposed and a new one replaces it (this is the workaround). widget 3, only sets the setAligment, and setOrientation - this does not work ok. The workaround (create new widget) works, but is not good enough. <code> package test; import org.eclipse.jface.viewers.IStructuredContentProvider; import org.eclipse.jface.viewers.ITableLabelProvider; import org.eclipse.jface.viewers.LabelProvider; import org.eclipse.jface.viewers.Viewer; import org.eclipse.swt.SWT; import org.eclipse.swt.custom.StyledText; import org.eclipse.swt.custom.VerifyKeyListener; import org.eclipse.swt.events.VerifyEvent; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.FormAttachment; import org.eclipse.swt.layout.FormData; import org.eclipse.swt.layout.FormLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Label; import org.eclipse.ui.ISharedImages; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.part.ViewPart; public class View extends ViewPart { private StyledText styledTextNotWorking; private StyledText styledText; private StyledText styledTextRTl; public static final String ID = "test.view"; class VeryListener implements VerifyKeyListener { public void verifyKey(VerifyEvent e) { if ((e.stateMask & SWT.SHIFT) != 0 && e.keyCode == SWT.CTRL || ((e.stateMask & SWT.CTRL) != 0 && e.keyCode == SWT.SHIFT)) { StyledText widget = (StyledText) e.getSource(); Object ld = widget.getLayoutData(); String text = widget.getText(); Composite par = widget.getParent(); int offset = widget.getCaretOffset(); int newOrientation = widget.getOrientation() == SWT.RIGHT_TO_LEFT ? SWT.LEFT_TO_RIGHT : SWT.RIGHT_TO_LEFT; widget.removeVerifyKeyListener(listener); widget.dispose(); widget = new StyledText(par, SWT.MULTI | SWT.WRAP | SWT.BORDER | SWT.V_SCROLL | newOrientation); widget.addVerifyKeyListener(listener); widget.setText(text); widget.setLayoutData(ld); widget.setCaretOffset(offset); widget.setFocus(); par.layout(); } } } VeryListener listener = new VeryListener(); /** * The content provider class is responsible for providing objects to the * view. It can wrap existing objects in adapters or simply return objects * as-is. These objects may be sensitive to the current input of the view, * or ignore it and always show the same content (like Task List, for * example). */ class ViewContentProvider implements IStructuredContentProvider { public void inputChanged(Viewer v, Object oldInput, Object newInput) { } public void dispose() { } public Object[] getElements(Object parent) { return new String[] { "One", "Two", "Three" }; } } class ViewLabelProvider extends LabelProvider implements ITableLabelProvider { public String getColumnText(Object obj, int index) { return getText(obj); } public Image getColumnImage(Object obj, int index) { return getImage(obj); } public Image getImage(Object obj) { return PlatformUI.getWorkbench().getSharedImages().getImage( ISharedImages.IMG_OBJ_ELEMENT); } } /** * This is a callback that will allow us to create the viewer and initialize * it. */ public void createPartControl(Composite parent) { final Composite composite = new Composite(parent, SWT.NONE); composite.setLayout(new FormLayout()); FormData formData_1; { styledTextRTl = new StyledText(composite, SWT.V_SCROLL | SWT.BORDER | SWT.WRAP); formData_1 = new FormData(); formData_1.bottom = new FormAttachment(0, 115); formData_1.top = new FormAttachment(0, 40); formData_1.right = new FormAttachment(0, 195); formData_1.left = new FormAttachment(0, 15); styledTextRTl.setLayoutData(formData_1); styledTextRTl.setText(""); styledTextRTl.addVerifyKeyListener(listener); } Label ltrLabel; { ltrLabel = new Label(composite, SWT.CENTER); final FormData formData = new FormData(); formData.right = new FormAttachment(100, -5); formData.top = new FormAttachment(0, 5); formData.left = new FormAttachment(styledTextRTl, 0, SWT.LEFT); ltrLabel.setLayoutData(formData); ltrLabel.setText("LTR"); } Label rtlLabel; { rtlLabel = new Label(composite, SWT.CENTER); final FormData formData = new FormData(); formData.bottom = new FormAttachment(0, 160); formData.top = new FormAttachment(0, 137); formData.right = new FormAttachment(100, -5); formData.left = new FormAttachment(0, 25); rtlLabel.setLayoutData(formData); rtlLabel.setText("RTL"); } { styledText = new StyledText(composite, SWT.V_SCROLL | SWT.BORDER | SWT.WRAP | SWT.RIGHT_TO_LEFT); final FormData formData = new FormData(); formData.bottom = new FormAttachment(0, 260); formData.left = new FormAttachment(0, 25); formData.right = new FormAttachment(0, 245); formData.top = new FormAttachment(0, 195); styledText.setLayoutData(formData); styledText.addVerifyKeyListener(listener); } { styledTextNotWorking = new StyledText(composite, SWT.V_SCROLL | SWT.BORDER); styledTextNotWorking.addVerifyKeyListener(new VerifyKeyListener() { public void verifyKey(VerifyEvent e) { if ((e.stateMask & SWT.SHIFT) != 0 && e.keyCode == SWT.CTRL || ((e.stateMask & SWT.CTRL) != 0 && e.keyCode == SWT.SHIFT)) { styledTextNotWorking .setOrientation(styledTextNotWorking .getOrientation() == SWT.RIGHT_TO_LEFT ? SWT.LEFT_TO_RIGHT : SWT.RIGHT_TO_LEFT); // do we need aligment here? styledTextNotWorking.setAlignment(styledTextNotWorking .getAlignment() == SWT.RIGHT ? SWT.LEFT : SWT.RIGHT); } } }); final FormData formData = new FormData(); formData.bottom = new FormAttachment(0, 385); formData.right = new FormAttachment(0, 230); formData.top = new FormAttachment(0, 310); formData.left = new FormAttachment(0, 40); styledTextNotWorking.setLayoutData(formData); } } /** * Passing the focus request to the viewer's control. */ public void setFocus() { styledTextNotWorking.setFocus(); } } </code>